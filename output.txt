/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   fractol.h                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jcouto <jcouto@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/19 21:05:11 by jcouto            #+#    #+#             */
/*   Updated: 2025/02/03 18:00:46 by jcouto           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef FRACTOL_H
# define FRACTOL_H

# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <math.h>
# include <X11/X.h>
# include <X11/keysym.h>
# include "minilibx-linux/mlx.h"

# define WIDTH 800
# define HEIGHT 800

# define ESC_KEY 65307
# define LEFT_ARROW 65361
# define RIGHT_ARROW 65363
# define UP_ARROW 65362
# define DOWN_ARROW 65364
# define M_KEY 109
# define L_KEY 108
# define SCROLL_UP 4
# define SCROLL_DOWN 5
# define R_KEY 114
# define I_KEY 105
# define O_KEY 111
# define C_KEY 99
# define V_KEY 118

# define BLACK       0x000000  
# define WHITE       0xFFFFFF 
# define RED         0xFF0000 
# define GREEN       0x00FF00
# define BLUE        0x0000FF
# define PSYCHEDELIC_RED     0xFF4500 
# define PSYCHEDELIC_PINK    0xFF1493
# define PSYCHEDELIC_PURPLE  0x9400D3
# define PSYCHEDELIC_YELLOW  0xFFD700
# define PSYCHEDELIC_GREEN   0x7FFF00
# define PSYCHEDELIC_BLUE    0x1E90FF
# define PSYCHEDELIC_CYAN    0x00FFFF
# define PSYCHEDELIC_ORANGE  0xFF6347
# define PSYCHEDELIC_TEAL    0x008080
# define PSYCHEDELIC_LIME    0x32CD32

typedef enum e_fractal_type
{
	Mandelbrot,
	Julia,
	Tricorn
}	t_fractal_type;

typedef struct s_img
{
	void	*img_ptr;
	char	*pixel_ptr;
	int		bpp;
	int		endian;
	int		line_len;
}	t_img;

typedef struct s_complex
{
	double	x;
	double	y;
}	t_complex;

typedef struct s_fractal
{
	void	*mlx_connection;
	void	*mlx_window;
	t_img	img;
	t_complex		min;
	t_complex		max;
	t_fractal_type 	type;
	int 	max_iterations;
	double	zoom;
	double		offset_x;
	double		offset_y;
	double	c_jx;
	double	c_jy;
	double	mouse_x;
	double	mouse_y;
	int		color_shift;
	int		color_cycle;
}	t_fractal;

int		ft_strncmp(const char *s1, const char *s2, size_t n);
void	ft_putendl_fd(char *s, int fd);
void	fractal_init(t_fractal *fractal);
double	map(double unscaled_num, t_complex old, t_complex new);
t_complex	complex_add(t_complex a, t_complex b);
t_complex	complex_square(t_complex a);
void	events_init(t_fractal *fractal);
void	data_init(t_fractal *fractal);
int		key_press(int keycode, t_fractal *fractal);
int		close_win(t_fractal *fractal);
int		mouse_press(int button, int x, int y, t_fractal *fractal);;
void	ft_pixel_put(t_fractal *fractal, int x, int y, int color);
void	handle_pixel(t_fractal *fractal, int x, int y, int max_iterations);
void	fractal_render(t_fractal *fractal);
double	ft_atod(const char *str);
int		mouse_move(int x, int y, t_fractal *fractal);
void	update_max_iterations(t_fractal *fractal);
int		cycle_color(t_fractal *fractal);
int		color_palette(t_fractal *fractal);
int		error_message(void);
void	instructions(void);
int		check_number(const char *str);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_events.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jcouto <jcouto@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/28 18:06:48 by jcouto            #+#    #+#             */
/*   Updated: 2025/02/03 17:02:25 by jcouto           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "fractol.h"

int	close_win(t_fractal *f)
{
	mlx_destroy_image(f->mlx_connection, f->img.img_ptr);
	mlx_destroy_window(f->mlx_connection, f->mlx_window);
	mlx_destroy_display(f->mlx_connection);
	free(f->mlx_connection);
	exit(0);
	return (0);
}

int	key_press(int keycode, t_fractal *f)
{
	if (keycode == ESC_KEY)
		close_win(f);
	else if (keycode == LEFT_ARROW)
		f->offset_x -= (.5 * f->zoom);
	else if (keycode == UP_ARROW)
		f->offset_y -= (.5 * f->zoom);
	else if (keycode == RIGHT_ARROW)
		f->offset_x += (.5 * f->zoom);
	else if (keycode == DOWN_ARROW)
		f->offset_y += (.5 * f->zoom);
	else if (keycode == M_KEY)
		f->max_iterations += 10;
	else if (keycode == L_KEY)
		f->max_iterations -= 10;
	else if (keycode == R_KEY)
		data_init(f);
	else if (keycode == C_KEY)
		cycle_color(f);
	else if (keycode == V_KEY)
		color_palette(f);
	fractal_render(f);
	return (0);
}

int	mouse_press(int button, int x, int y, t_fractal *f)
{
	double	zoom_factor;
	double	mouse_fractal_x;
	double	mouse_fractal_y;

	mouse_fractal_x = map(x, f->min.x, f->max.x, 0, WIDTH);
	mouse_fractal_y = map(y, f->min.y, f->max.y, 0, HEIGHT);
	zoom_factor = 1.1;
	if (button == SCROLL_DOWN)
	{
		f->zoom *= zoom_factor;
		f->offset_x += (mouse_fractal_x - f->offset_x) * (1 - 1 / zoom_factor);
		f->offset_y += (mouse_fractal_y - f->offset_y) * (1 - 1 / zoom_factor);
	}
	else if (button == SCROLL_UP)
	{
		f->zoom /= zoom_factor;
		f->offset_x -= (mouse_fractal_x - f->offset_x) * (1 - zoom_factor);
		f->offset_y -= (mouse_fractal_y - f->offset_y) * (1 - zoom_factor);
	}
	update_max_iterations(f);
	fractal_render(f);
	return (0);
}

int	mouse_move(int x, int y, t_fractal *f)
{
	static int	last_x = -1, last_y = -1;

	if (f->type == Julia && (abs(x - last_x) > 10 || abs(y - last_y) > 10))
	{
		f->c_jx = map(x, f->min.x, f->max.x, 0, WIDTH) * f->zoom + f->offset_x;
		f->c_jy = map(y, f->min.y, f->max.y, 0, HEIGHT) * f->zoom + f->offset_y;
		fractal_render(f);
		last_x = x;
		last_y = y;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_render.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jcouto <jcouto@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/28 18:07:01 by jcouto            #+#    #+#             */
/*   Updated: 2025/02/03 17:44:54 by jcouto           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "fractol.h"

void	ft_pixel_put(t_fractal *f, int x, int y, int color)
{
	char	*pixel;

	pixel = f->img.pixel_ptr + (y * f->img.line_len + x * (f->img.bpp / 8));
	*(unsigned int *)pixel = color;
}

void	handle_pixel(t_fractal *f, int x, int y, int max_iterations)
{
	t_complex	c;
	t_complex	z;
	int			iterations;
	int			color;

	iterations = 0;
	c.x = map(x, f->min.x, f->max.x, 0, WIDTH) * f->zoom + f->offset_x;
	c.y = map(y, f->min.y, f->max.y, 0, HEIGHT) * f->zoom + f->offset_y;
	if (f->type == Mandelbrot || f->type == Tricorn)
	{
		z.x = c.x;
		z.y = c.y;
	}
	else if (f->type == Julia)
	{
		z.x = map(x, f->min.x, f->max.x, 0, WIDTH) * f->zoom + f->offset_x;
		z.y = map(y, f->min.y, f->max.y, 0, HEIGHT) * f->zoom + f->offset_y;
		c.x = f->c_jx;
		c.y = f->c_jy;
	}
	while (iterations < max_iterations)
	{
		if (f->type == Tricorn)
		{
			c.x = z.x;
			c.y = -z.y;
		}
		z = complex_add(complex_square(z), c);
		if ((z.x * z.x + z.y * z.y) > 4)
		{
			color = map(iterations, f->color_cycle, f->color_shift, 0, f->max_iterations);
			ft_pixel_put(f, x, y, color);
			return ;
		}
		iterations++;
	}
	ft_pixel_put(f, x, y, BLACK);
}

void	fractal_render(t_fractal *f)
{
	int	x;
	int	y;

	y = 0;
	while (y < HEIGHT)
	{
		x = 0;
		while (x < WIDTH)
		{
			handle_pixel(f, x, y, f->max_iterations);
			x++;
		}
		y++;
	}
	mlx_put_image_to_window(f->mlx_connection, f->mlx_window, f->img.img_ptr, 0, 0);
}

void	update_max_iterations(t_fractal *f)
{
	f->max_iterations = (int)(42 + 50 * log(f->zoom + 1.0));
}
